\documentclass[12pt,a4paper]{scrartcl}

\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}

\usepackage{amsmath}
\usepackage{listings}
\usepackage[section]{placeins}
\usepackage{placeins}
\usepackage{graphicx}
\usepackage{subfig}

\typearea{14}

\begin{document}

\title{Scotland Yard}
\author{Razvan Dan David, Stefan Pruna}
\maketitle

\section{Model}
The first part of the coursework was \textit{cw-model}. Our task was to pass all tests by completing the implementation of the ScotlandYardModel class. This involved implementing the constructor, the \textit{ScotlandYardGame}, \textit{Consumer} and the \textit{MoveVisitor} interfaces, but also some auxiliary methods.

\subsection*{The constructor}
The constructor for the \textit{ScotlandYardModel} class ensures that all data that was passed in as arguments is valid and can be processed and copied into the class data structures. There are many types of validity checks, including checks for null pointers, valid colour and locations and appropriate tickets. \textit{PlayerConfigurations} are converted to \textit{ScotlandYardPlayers} and added to a list of players that is used later on in the class.

\subsection*{The ScotlandYardGame interface}
There are many functions that we implemented in order for our class to implement the \textit{ScotlandYardGame} interface, but two that stand out as being very important for the gameplay are \textit{startRotate} and \textit{isGameOver} (or \textit{getWinningPlayer}). In the functions used to check if the game is over or to get the colours of winning players, we checked four game-ending conditions: if there are more rounds to be played, if mr. X or the detectives are stuck and if mr. X has been captured.

\subsubsection*{Valid move generation} 
In order to correctly implement \textit{startRotate}, we needed to generate a collection of all valid moves a player can make from their positions and with their ticket configuration. We did this by iterating over all the edges available from the player's current location and adding the simple moves that the player has the tickets to make, to a collection. To generate the double moves, we checked if the player has a double move ticket, and iterated over the available edges for all the previously generated simple moves, just as for the simple moves.

\subsubsection*{Move accepting callback, visitors}
Players are given a collection of valid moves that they can make, and a method to call when they decided which move to make. This method, \textit{accept},  is included in the \textit{Consumer} interface, which we implemented. It takes a generic \textit{Move} object as argument, checks if the selected move is valid and executes game logic. In order to get the type of move the player selected and to be able to execute game logic, we made use of the visitor pattern by implementing the \textit{MoveVisitor} interface. This meant creating three overloaded methods in which we had access to the type of move used by the player. In these three methods, we removed the used tickets, added tickets to mr. X, moved players, incremented rounds and current player turns, and notified spectators.

\section{AI}
The second part of the coursework was \textit{cw-ai}. Our task was to implement an artificial intelligence that can choose the best move for mr. X. We had to create a scoring method and implement the MinMax algorithm, but also come up with creative ideas to make our program more efficient.

\subsection*{The scoring method}
We decided to use three scoring criteria involving the available moves of mr. X, the average distance to the detectives and the minimum distance to them. To compute the distances from mr. X to the detectives, we used a Breadth First Search algorithm.
We normalized the three scores such that each of the three would range between 0 and 100. After some trial end error, we ended up combining these threee scores as follows: 70\% of the final score is the minimum distance score, 20\% is the available move score, and 10\% is the average distance score.

\subsection*{MinMax}
In order to make our A.I. more powerful we implemented the MinMax algorithm and optimized it with Alpha-Beta pruning for more performance. We generate the game tree recursively with a maximum depth of three and choose the best move mr. X can make using the scoring method we created. . In order to model the game state, we created two new classes, \textit{ScotlandYardAIModel} and \textit{ScotlandYardAIPlayer}, inspired from \textit{ScotlandYardView} and \textit{ScotlandYardPlayer}, but which support modifying the game state in an easier way.

\subsection*{Caching}
Because starting a Breadth First Search algorithm for each possible move MinMax generates is computationally costly, we came up with a Caching system. We generated a 5D matrix (200*200*12*9*5), with the following mapping: (start node, end node, number of taxi tickets, number of bus tickets, number of underground tickets). 
We stored the minimum distance in which a player with a certain 3-tuple configuration of tickets (last three dimensions of the matrix) can go from one node to another (the first two dimensions).
This matrix takes about 60 seconds to be computed. As such, we saved it as a binary file (21.4 MB of size), that we can easily load when the A.I. is first started.

\section{Reflection}

\paragraph{BFS} After implementing the Breadth First Search, we figured out that there were other ways in which nodes could be reached in the same amount of steps, but with a better future ticket configurations. We modified our algorithm such that it also considers the cases in which a player can move using two different types of transportation to the same node, generating different states in which that node can be reached.

\paragraph{Caching} We also implemented a caching system for the number of valid moves a player can make from each node, similarly to the minimum distance cache explained earlier. Later on, we realised that that the data stored in this cache was flawed, as we didn't take other players standing in the way into account. We decided to leave the source code, but generate the number of moves for each MinMax call.

\paragraph{Further performance improvements} We think that to further improve the performance of our A.I., we could simulate some of the configurations generated by the MinMax algorithm on different threads. We decided not to tackle this further optimisation, as we lack the experience in parallel computation.

\paragraph{Conclusion}
By doing this project, we have learned valuable lessons about object-oriented programming paradigms and team work. These include the usage of github or other version control software, the practicality of the visitor design pattern in big software projects like this one, and the importance of planning ahead when writing code.


\end{document}