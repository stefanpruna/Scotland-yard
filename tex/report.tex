\documentclass[12pt,a4paper]{scrartcl}

\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}

\usepackage{amsmath}
\usepackage{listings}
\usepackage[section]{placeins}
\usepackage{placeins}
\usepackage{graphicx}
\usepackage{subfig}

\typearea{14}

\begin{document}

\title{Scotland Yard}
\author{Razvan Dan David, Stefan Pruna}
\maketitle

\section{Model}
The first part of the coursework was \textit{cw-model}. Our task was to pass all tests by completing the implementation of the ScotlandYardModel class. This involved implementing the constructor, the \textit{ScotlandYardGame}, \textit{Consumer} and the \textit{MoveVisitor} interfaces, but also some auxiliary methods.

\subsection*{The constructor}
The constructor for the \textit{ScotlandYardModel} class ensures that all data that was passed in as arguments is valid and can be processed and copied into the class data structures. There are many types of validity checks, including checks for null pointers, valid colour and locations and appropriate tickets. \textit{PlayerConfigurations} are converted to \textit{ScotlandYardPlayers} and added to a list of players that is used later on in the class.

\subsection*{The ScotlandYardGame interface}
There are many functions that we implemented in order for our class to implement the \textit{ScotlandYardGame} interface, but two that stand out as being very important for the gameplay are \textit{startRotate} and \textit{isGameOver} (or \textit{getWinningPlayer}). In the functions used to check if the game is over or to get the colours of winning players, we checked four game-ending conditions: if there are more rounds to be played, if mr. X or the detectives are stuck and if mr. X has been captured.

\subsubsection*{Valid move generation} 
In order to correctly implement \textit{startRotate}, we needed to generate a collection of all valid moves a player can make from their positions and with their ticket configuration. We did this by iterating over all the edges available from the player's current location and adding the simple moves that the player has the tickets to make, to a collection. To generate the double moves, we checked if the player has a double move ticket, and iterated over the available edges for all the previously generated simple moves, just as for the simple moves.

\subsubsection*{Move accepting callback, visitors}
Players are given a collection of valid moves that they can make, and a method to call when they decided which move to make. This method, \textit{accept},  is included in the \textit{Consumer} interface, which we implemented. It takes a generic \textit{Move} object as argument, checks if the selected move is valid and executes game logic. In order to get the type of move the player selected and to be able to execute game logic, we made use of the visitor pattern by implementing the \textit{MoveVisitor} interface. This meant creating three overloaded methods in which we had access to the type of move used by the player. In these three methods, we removed the used tickets, added tickets to mr. X, moved players, incremented rounds and current player turns, and notified spectators.

\section{AI}


\end{document}